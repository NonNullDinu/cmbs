use crate::{
	grammar::{
		lexer,
		lexer::TokLoc,
		ast::*,
	},
};

grammar;

match {
    "+=",
    "-=",
    "*=",
    "/=",
    "%=",
    "+",
    "-",
    "*",
    "/",
    "%",
    "==",
    ">=",
    ">",
    "<=",
    "<",
    "!=",
    "=",
    "(",
    "[",
    "{",
    ")",
    "]",
    "}",
    ".",
    ":",
    "?",
    ";",
    ",",
    "and",
    "or",
    "not",
    "in",
    "let",
    "if",
    "else",
    "foreach",
    "continue",
    "break",
    "true",
    "false",
    r"([1-9][0-9]*|0x[0-9a-fA-F]+|0b[01]+|0[0-7]*)[uU]?[lL]?",
    r"[a-zA-Z_][a-zA-Z0-9_]*",
    r#"'(\\['nt\\]|[^'\\])+'"#,
    r#"'''([^']*|[']{1,2}[^'])*'''"#,
}


IdExpression: (String, TokLoc) = { <begin: @L> <id: r"[a-zA-Z_][a-zA-Z0-9_]*"> <end: @R> => (String::from(id), TokLoc::new(begin, end))};
Num: (NumVal, TokLoc) = {
    <begin: @L> <num: r"([1-9][0-9]*|0x[0-9a-fA-F]+|0b[01]+|0[0-7]*)[uU]?[lL]?"> <end: @R> => (NumVal::from(num), TokLoc::new(begin, end))
};
BoolLit: (bool, TokLoc) = {
    <begin: @L> "true" <end: @R> => (true, TokLoc::new(begin, end)),
    <begin: @L> "false" <end: @R> => (false, TokLoc::new(begin, end)),
};
Str: (String, TokLoc) = {
    <begin: @L> <s: r#"'(\\['nt\\]|[^'\\])+'"#> <end: @R> => (String::from(&s[1..(s.len()-1)]), TokLoc::new(begin, end)),
    <begin: @L> <s: r#"'''([^']*|[']{1,2}[^'])*'''"#> <end: @R> => (String::from(&s[3..(s.len()-3)]), TokLoc::new(begin, end)),
};
UnaryNot: UnaryOpcode = { <begin: @L> "not" <end: @R> => UnaryOpcode::Not(TokLoc::new(begin, end)) };

pub Program = <Statement*>;
Statement: AstStatement = {
    <MethodCall> ";" => AstStatement::MethodCall(<>),
	<FuncCall> ";" => AstStatement::FuncCall(<>),
	<Assignment> ";" => AstStatement::Assignment(<>),
	<Declaration> ";" => AstStatement::Declaration(<>),
	<ConditionalStatement> => AstStatement::Conditional(<>),
	//<ControlStatement> => AstStatement::ControlStatement(<>),
	<RepetitiveStatement> => AstStatement::Repetitive(<>),
};

FuncCall: AstFuncCall = {
	<name:IdExpression> "(" <args:FuncArgs> ")" <end: @R> => AstFuncCall::new(name, args, end)
};

FuncArgs:AstFuncCallArgs = {
	<pos_args:PositionalFuncArgs> "," <named_args:NamedFuncArgs> ","? => AstFuncCallArgs::new(pos_args,named_args),
	<pos_args:PositionalFuncArgs> ","? => AstFuncCallArgs::new_only_positional(pos_args),
	<named_args:NamedFuncArgs> ","? => AstFuncCallArgs::new_only_named(named_args),
	() => AstFuncCallArgs::empty(),
};

#[inline]
PositionalFuncArgs: Vec<AstPositionalArg> = {
	<arg1:PositionalFuncArg> <rest:("," <PositionalFuncArg>)*> => {let mut v = vec![arg1]; v.extend(rest); v.into_iter().map(|box_ : Box<Expr>| AstPositionalArg::from(box_)).collect()},
};

PositionalFuncArg = { Expr };

#[inline]
NamedFuncArgs: Vec<AstNamedExpr> = {
	<arg1:NamedExpr> <rest:("," <NamedExpr>)*> => {let mut v = vec![arg1]; v.extend(rest); v}
};

NamedExpr: AstNamedExpr = {
	<name:IdExpression> ":" <value:Expr> => AstNamedExpr::from((name, value))
};

AddExpr: Box<Expr> = { // (1)
    AddExpr AddOp Factor => Box::new(Expr::Op(<>)), // (2)
    Factor,
};

AddOp: Opcode = { // (3)
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

CheckExpr: Box<Expr> = {
	AddExpr RelOp AddExpr => Box::new(Expr::Op(<>)),
	AddExpr,
};

AndConditionalExpr: Box<Expr> = {
	AndConditionalExpr AndOp CheckExpr => Box::new(Expr::Op(<>)),
	CheckExpr,
};

AndOp: Opcode = {
	"and" => Opcode::And,
};

OrConditionalExpr: Box<Expr> = {
	OrConditionalExpr OrOp AndConditionalExpr => Box::new(Expr::Op(<>)),
	AndConditionalExpr,
};

OrOp: Opcode = {
	"or" => Opcode::Or,
};

RelOp: Opcode = {
	"==" => Opcode::Equal,
	">" => Opcode::G,
	"<" => Opcode::L,
	">=" => Opcode::GE,
	"<=" => Opcode::LE,
	"!=" => Opcode::NE,
	"in" => Opcode::In,
	"not" "in" => Opcode::NotIn,
};

Expr: Box<Expr> = {
	OrConditionalExpr,
};

Factor: Box<Expr> = {
    Factor FactorOp TermWithUnaryOps => Box::new(Expr::Op(<>)),
    TermWithUnaryOps,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
    "%" => Opcode::Mod,
};

TermWithUnaryOps: Box<Expr> = {
	UnaryNeg Term => Box::new(Expr::UnaryOp(<>)),
	UnaryNot Term => Box::new(Expr::UnaryOp(<>)),
	Term,
};

Term: Box<Expr> = {
    Num => Box::new(Expr::Atom(Atom::Number(<>))),
    Str => Box::new(Expr::Atom(Atom::Str(<>))),
    BoolLit => Box::new(Expr::Atom(Atom::Bool(<>))),
    <begin: @L> "(" <value:Expr> ")" <end: @R> => Box::new(Expr::ParenExpr(begin, value, end)),
    <MethodCall> => Box::new(Expr::MethodCall(<>)),
    <PropertyAccess> => Box::new(Expr::PropertyAccess(<>)),
    <FuncCall> => Box::new(Expr::FuncCall(<>)),
    <IdExpression> => Box::new(Expr::Atom(Atom::Id(<>))),
    <base:Term> "[" <ind:Expr> "]" <end: @R> => Box::new(Expr::Indexed{base, index: ind, end}),
    ArrayLit, MapLit, Ternary,
};

Ternary: Box<Expr> = {
    <begin: @L> "(" <cond: Expr> "?" <tr: Expr> ":" <fal: Expr> ")" <end: @R> => Box::new(Expr::Ternary(<>)),
};

UnaryNeg: UnaryOpcode = {
	<begin: @L> "-" <end: @R> => UnaryOpcode::Neg(TokLoc::new(<>)),
};

PropertyAccess: AstPropertyAccess = {
    <t:Term> "." <prop_name:IdExpression> => AstPropertyAccess::new(t, prop_name)
};

MethodCall: AstMethodCall = {
	<property_access:PropertyAccess> "(" <args:FuncArgs> ")" <end: @R> => AstMethodCall::new(property_access, args, end),
};

Declaration: AstDeclaration = {
	<begin: @L> "let" <name: IdExpression> "=" <value: Expr> => AstDeclaration::new(name, value, begin)
};

Assignment: AstAssignment = {
	<bind_name: Expr> <op: AtrOp> <val: Expr> => AstAssignment::new(bind_name, op, val),
};

AtrOp: AstAtrOp = {
	"=" => AstAtrOp::Atr,
	"+=" => AstAtrOp::AddAtr,
	"-=" => AstAtrOp::SubAtr,
	"*=" => AstAtrOp::MulAtr,
	"/=" => AstAtrOp::DivAtr,
	"%=" => AstAtrOp::ModAtr,
};

ArrayLit: Box<Expr> = {
	<begin: @L> "{" <arg1:Expr> <rest:("," <Expr>)*> ","? "}" <end: @R> => Box::new(Expr::Atom(Atom::ArrayLit(({let mut v = vec![arg1]; v.extend(rest); v}, TokLoc::new(begin, end)))))
};

MapLit: Box<Expr> = {
	<begin: @L> "{" <arg1:NamedExpr> <rest:("," <NamedExpr>)*>  ","?  "}" <end: @R> => Box::new(Expr::Atom(Atom::MapLit(({let mut v = vec![arg1]; v.extend(rest); v}, TokLoc::new(begin, end)))))
};

#[inline]
ConditionalStatement: AstConditionalStatement = {
	<initial: If> <others: ElseIf*> <else_statement: Else?> => AstConditionalStatement::new(initial, others, else_statement),
};

If: AstIf = {
	<begin: @L> "if" <cond: Expr> "{" <statements: Statement*> "}" <end: @R> => AstIf::new(<>),
};

ElseIf: AstElseIf = {
	<begin: @L> "else" <if_: If> => AstElseIf::new(<>),
};

Else: AstElse = {
	<begin:@L> "else" "{" <statements: Statement+> "}" <end: @R> => AstElse::new(<>),
};

RepetitiveStatement: AstRepetitiveStatement = {
    <foreach_tok: @L> "foreach" <for_in_expr: ForInExpr> "{" <statement:Statement*> "}" <end: @R> => AstRepetitiveStatement::new(<>),
};

ForInExpr: AstForInExpr = {
    <id: IdExpression> "in" <expr: Expr> => AstForInExpr::new(<>),
};

ControlStatement: AstControlStatement = {
	<begin: @L> "break" <end: @R> => AstControlStatement::Break(TokLoc::new(<>)),
	<begin: @L> "continue" <end: @R> => AstControlStatement::Continue(TokLoc::new(<>)),
};

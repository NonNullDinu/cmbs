use crate::{
	grammar::{
		lexer,
		lexer::TokLoc,
		ast::*,
	},
};

grammar;

match {
    "+=",
    "-=",
    "*=",
    "/=",
    "%=",
    "+",
    "-",
    "*",
    "/",
    "%",
    "==",
    ">=",
    ">",
    "<=",
    "<",
    "!=",
    "=",
    "<<",
    ">>",
    "(",
    "[",
    "{",
    ")",
    "]",
    "}",
    ".",
    ":",
    "?",
    ";",
    ",",
    "~",
    "and",
    "or",
    "not",
    "in",
    "let",
    "if",
    "else",
    "foreach",
    "continue",
    "break",
    "true",
    "false",
    r"([1-9][0-9]*|0x[0-9a-fA-F]+|0b[01]+|0[0-7]*)[uU]?[lL]?",
    r"[a-zA-Z_][a-zA-Z0-9_]*",
    r#"'(\\['nt\\]|[^'\\])+'"#,
    r#"'''([^']*|[']{1,2}[^'])*'''"#,
}

SpannedTok<Rule>: (Rule, TokLoc) = <begin: @L> <rule: Rule> <end: @R> => (rule, TokLoc::new(begin, end));
SpannedLocation<Rule>: TokLoc = <begin: @L> <rule: Rule> <end: @R> => TokLoc::new(begin, end);

SingleComma: () = {
    "," => (),
};

#[inline]
Comma<Rule>: Vec<Rule> =
    <mut rules: (<Rule> SingleComma)*> <last: Rule?> => {
        rules.extend(last);
        rules
    };

#[inline]
CommaNoTrailing<Rule>: Vec<Rule> =
    <first: Rule> <mut rules: (SingleComma <Rule>)*> => { rules.insert(0, first); rules };

IdExpressionUnspanned: String =
    <id: r"[a-zA-Z_][a-zA-Z0-9_]*"> => String::from(id);

IdExpression = SpannedTok<IdExpressionUnspanned>;

NumTok: NumVal = {
    <num: r"([1-9][0-9]*|0x[0-9a-fA-F]+|0b[01]+|0[0-7]*)[uU]?[lL]?"> => NumVal::from(num)
};

Num = SpannedTok<NumTok>;

BoolTok: bool = {
    "true" => true,
    "false" => false,
};

BoolLit = SpannedTok<BoolTok>;

StrTok: String = {
    <s: r#"'(\\['nt\\]|[^'\\])+'"#> => String::from(&s[1..(s.len()-1)]),
    <s: r#"'''([^']*|[']{1,2}[^'])*'''"#> => String::from(&s[3..(s.len()-3)]),
};

Str = SpannedTok<StrTok>;

UnaryNot: UnaryOpcode = { <l: SpannedLocation<"not">> => UnaryOpcode::Not(l) };

pub Program = <Statement*>;
Statement: AstStatement = {
//    <call: MethodCall> ";" => AstStatement::MethodCall(call),
	<call: FuncCall> ";" => AstStatement::FuncCall(call),
	<assignment: Assignment> ";" => AstStatement::Assignment(assignment),
	<declaration: Declaration> ";" => AstStatement::Declaration(declaration),
	<statement: ConditionalStatement> => AstStatement::Conditional(statement),
	//<statement ControlStatement> => AstStatement::ControlStatement(statement),
	<statement: RepetitiveStatement> => AstStatement::Repetitive(statement),
};

// function calls
FuncCall: AstFuncCall = {
	<name:IdExpression> "(" <args:FuncArgs> ")" <end: @R> => AstFuncCall::new(name, args, end)
};

FuncArgs: AstFuncCallArgs = {
	<pos_args:PositionalFuncArgs> SingleComma <named_args:NamedFuncArgs> SingleComma? => AstFuncCallArgs::new(pos_args,named_args),
	<pos_args:PositionalFuncArgs> SingleComma? => AstFuncCallArgs::new_only_positional(pos_args),
	<named_args:NamedFuncArgs> SingleComma? => AstFuncCallArgs::new_only_named(named_args),
	() => AstFuncCallArgs::empty(),
};

#[inline]
PositionalFuncArgs = CommaNoTrailing<PositionalFuncArg>;

PositionalFuncArg: AstPositionalArg = <expr: Expr> => AstPositionalArg::from(expr);

#[inline]
NamedFuncArgs = CommaNoTrailing<NamedExpr>;

NamedExpr: AstNamedExpr = {
	<name:IdExpression> "=" <value:Expr> => AstNamedExpr::from((name, value))
};

UnaryPlusMinusOpcode: UnaryOpcode = {
	<l: SpannedLocation<"-">> => UnaryOpcode::Minus(l),
	<l: SpannedLocation<"+">> => UnaryOpcode::Plus(l),
};

UnaryPlusMinusExpression: Box<Expr> = {
    <op: UnaryPlusMinusOpcode> <expr: UnaryPlusMinusExpression> => Box::new(Expr::UnaryOp(op, expr)),
};

UnaryLogicalAndBitwiseNot: UnaryOpcode = {
	<l: SpannedLocation<"not">> => UnaryOpcode::Not(l),
	<l: SpannedLocation<"~">> => UnaryOpcode::BitwiseNot(l),
};

UnaryLogicalAndBitwiseNotExpression: Box<Expr> = {
    <op: UnaryLogicalAndBitwiseNot> <expr: UnaryPlusMinusExpression> => Box::new(Expr::UnaryOp(op, expr)),
};

MulOp: Opcode = {
    <l: SpannedLocation<"*">> => Opcode::Mul(l),
    <l: SpannedLocation<"/">> => Opcode::Div(l),
    <l: SpannedLocation<"%">> => Opcode::Mod(l),
};

Factor: Box<Expr> = {
    <left: Factor> <op: MulOp> <right: UnaryLogicalAndBitwiseNotExpression> => Box::new(Expr::Op(left, op, right)),
    UnaryLogicalAndBitwiseNotExpression,
};

AddOp: Opcode = {
    <l: SpannedLocation<"+">> => Opcode::Add(l),
    <l: SpannedLocation<"-">> => Opcode::Sub(l),
};

AddExpr: Box<Expr> = {
    <left: AddExpr> <op: AddOp> <right: Factor> => Box::new(Expr::Op(left, op, right)),
    Factor,
};

BitShiftOp: Opcode = {
    <l: SpannedLocation<"<<">> => Opcode::LBitshift(l),
    <l: SpannedLocation<">>">> => Opcode::RBitshift(l)
};

BitShiftExpr: Box<Expr> = {
    <left: BitShiftExpr> <op: BitShiftOp> <right: AddExpr> => Box::new(Expr::Op(left, op, right)),
    AddExpr,
};

RelOp: Opcode = {
	<l: SpannedLocation<">">> => Opcode::G(l),
	<l: SpannedLocation<"<">> => Opcode::L(l),
	<l: SpannedLocation<">=">> => Opcode::GE(l),
	<l: SpannedLocation<"<=">> => Opcode::LE(l),
	<l: SpannedLocation<"in">> => Opcode::In(l),
	<l: SpannedLocation<("not" "in")>> => Opcode::NotIn(l),
};

RelExpr: Box<Expr> = {
	<left: RelExpr> <op: RelOp> <right: BitShiftExpr> => Box::new(Expr::Op(left, op, right)),
	AddExpr,
};

RelOp2: Opcode = {
    <l: SpannedLocation<"==">> => Opcode::Equal(l),
    <l: SpannedLocation<"!=">> => Opcode::NE(l),
}

RelExpr2: Box<Expr> = {
	<left: RelExpr2> <op: RelOp2> <right: RelExpr> => Box::new(Expr::Op(left, op, right)),
	RelExpr,
};

AndConditionalExpr: Box<Expr> = {
	<left: AndConditionalExpr> <op: AndOp> <right: RelExpr2> => Box::new(Expr::Op(left, op, right)),
	RelExpr2,
};

AndOp: Opcode = {
	<l: SpannedLocation<"and">> => Opcode::And(l),
};

OrConditionalExpr: Box<Expr> = {
	<left: OrConditionalExpr> <op: OrOp> <right: AndConditionalExpr> => Box::new(Expr::Op(left, op, right)),
	AndConditionalExpr,
};

OrOp: Opcode = {
    <l: SpannedLocation<"or">> => Opcode::Or(l),
};

TernaryExpr: Box<Expr> = {
    <condition: OrConditionalExpr> <qmark: SpannedLocation<"?">> <val_true: TernaryExpr> <colon: SpannedLocation<":">> <val_false: OrConditionalExpr> => Box::new(Expr::Ternary(condition, qmark, val_true, colon, val_false)),
    OrConditionalExpr
};

Expr = TernaryExpr;

//MemberAccessExpr: AstPropertyAccess = {
//    <t:Term> <dot: SpannedLocation<".">> <prop_name:IdExpression> => AstPropertyAccess::new(t, dot, prop_name),
//};
//
//MethodCall: AstMethodCall = {
//	<property_access:MemberAccess> "(" <args:FuncArgs> ")" <end: @R> => AstMethodCall::new(property_access, args, end),
//};

Declaration: AstDeclaration = {
	<begin: @L> "let" <name: IdExpression> "=" <value: Expr> => AstDeclaration::new(name, value, begin)
};

Assignment: AstAssignment = {
	<bind_name: Expr> <op: AtrOp> <val: Expr> => AstAssignment::new(bind_name, op, val),
};

AtrOp: AstAtrOp = {
	<l: SpannedLocation<"=">> => AstAtrOp::Atr(l),
	<l: SpannedLocation<"+=">> => AstAtrOp::AddAtr(l),
	<l: SpannedLocation<"-=">> => AstAtrOp::SubAtr(l),
	<l: SpannedLocation<"*=">> => AstAtrOp::MulAtr(l),
	<l: SpannedLocation<"/=">> => AstAtrOp::DivAtr(l),
	<l: SpannedLocation<"%=">> => AstAtrOp::ModAtr(l),
};

ArrayLit: Box<Expr> = {
	<begin: @L> "{" <arg1:Expr> <rest:("," <Expr>)*> ","? "}" <end: @R> =>
            Box::new(Expr::Atom(Atom::ArrayLit((
                { let mut v = Vec::with_capacity(1 + rest.len()); v.push(arg1); v.extend(rest); v },
                TokLoc::new(begin, end),
            ))))
};

MapLit: Box<Expr> = {
	<begin: @L> "{" <arg1:NamedExpr> <rest:("," <NamedExpr>)*>  ","?  "}" <end: @R> =>
            Box::new(Expr::Atom(Atom::MapLit((
                { let mut v = Vec::with_capacity(1 + rest.len()); v.push(arg1); v.extend(rest); v },
                TokLoc::new(begin, end),
            ))))
};

#[inline]
ConditionalStatement: AstConditionalStatement = {
	<initial: If> <others: ElseIf*> <else_statement: Else?> => AstConditionalStatement::new(initial, others, else_statement),
};

If: AstIf = {
	<begin: @L> "if" <cond: Expr> "{" <statements: Statement*> "}" <end: @R> => AstIf::new(<>),
};

ElseIf: AstElseIf = {
	<begin: @L> "else" <if_: If> => AstElseIf::new(<>),
};

Else: AstElse = {
	<begin:@L> "else" "{" <statements: Statement+> "}" <end: @R> => AstElse::new(<>),
};

RepetitiveStatement: AstRepetitiveStatement = {
    <foreach_tok: @L> "foreach" <for_in_expr: ForInExpr> "{" <statement:Statement*> "}" <end: @R> => AstRepetitiveStatement::new(<>),
};

ForInExpr: AstForInExpr = {
    <id: IdExpression> "in" <expr: Expr> => AstForInExpr::new(<>),
};

ControlStatement: AstControlStatement = {
	<begin: @L> "break" <end: @R> => AstControlStatement::Break(TokLoc::new(<>)),
	<begin: @L> "continue" <end: @R> => AstControlStatement::Continue(TokLoc::new(<>)),
};

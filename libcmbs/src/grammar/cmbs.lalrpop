use std::str::FromStr;
use crate::{
	grammar::{
		lexer,
		ast::{
			Atom,
			Expr,
			Opcode,
			AstFuncCall,
			AstFuncCallArgs,
			AstPositionalArg,
			AstNamedArg,
			AstMethodCall,
			AstStatement,
			AstAssignment,
			AstAtrOp,
			AstPropertyAccess,
		},
	},
};

grammar;

pub Program = <Statement*>;
Statement: AstStatement = {
    <MethodCall> "\n" => AstStatement::MethodCall(<>),
	<FuncCall> "\n" => AstStatement::FuncCall(<>),
	<Assignment> "\n" => AstStatement::Assignment(<>),
};

FuncCall: AstFuncCall = {
	<name:IdExpression> "(" <args:FuncArgs> ")" => AstFuncCall::new(name, args)
};

pub FuncArgs:AstFuncCallArgs = {
	<pos_args:PositionalFuncArgs> "," <named_args:NamedFuncArgs> ","? => AstFuncCallArgs::new(pos_args,named_args),
	<pos_args:PositionalFuncArgs> ","? => AstFuncCallArgs::new_only_positional(pos_args),
	<named_args:NamedFuncArgs> ","? => AstFuncCallArgs::new_only_named(named_args),
	() => AstFuncCallArgs::empty(),
};

#[inline]
PositionalFuncArgs: Vec<AstPositionalArg> = {
	<arg1:PositionalFuncArg> <rest:("," <PositionalFuncArg>)*> => {let mut v = vec![arg1]; v.extend(rest); v.into_iter().map(|box_ : Box<Expr>| AstPositionalArg::from(box_)).collect()},
};

pub PositionalFuncArg = { Expr };

#[inline]
NamedFuncArgs: Vec<AstNamedArg> = {
	<arg1:NamedFuncArg> <rest:("," <NamedFuncArg>)*> => {let mut v = vec![arg1]; v.extend(rest); v}
};

pub NamedFuncArg: AstNamedArg = {
	<name:IdExpression> ":" <value:Expr> => AstNamedArg::from((name, value))
};

pub Expr: Box<Expr> = { // (1)
    Expr ExprOp Factor => Box::new(Expr::Op(<>)), // (2)
    Factor,
};

ExprOp: Opcode = { // (3)
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

Factor: Box<Expr> = {
    Factor FactorOp Term => Box::new(Expr::Op(<>)),
    Term,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
    "%" => Opcode::Mod,
};

Term: Box<Expr> = {
    "num" => Box::new(Expr::Atom(Atom::Number(<>))),
    "(" <Expr> ")",
    <MethodCall> => Box::new(Expr::MethodCall(<>)),
    <PropertyAccess> => Box::new(Expr::PropertyAccess(<>)),
    <FuncCall> => Box::new(Expr::FuncCall(<>)),
    <IdExpression> => Box::new(Expr::Atom(Atom::Id(<>))),
};

PropertyAccess: AstPropertyAccess = {
    <t:Term> "." <prop_name:IdExpression> => AstPropertyAccess::new(t, prop_name)
};

MethodCall: AstMethodCall = {
	<property_access:PropertyAccess> "(" <args:FuncArgs> ")" => AstMethodCall::new(property_access, args),
};

Assignment: AstAssignment = {
	<var_name: IdExpression> <op: AtrOp> <val: Expr> => AstAssignment::new(var_name, op, val),
}

AtrOp: AstAtrOp = {
	"=" => AstAtrOp::Atr,
	"+=" => AstAtrOp::AddAtr,
	"-=" => AstAtrOp::SubAtr,
	"*=" => AstAtrOp::MulAtr,
	"/=" => AstAtrOp::DivAtr,
	"%=" => AstAtrOp::ModAtr,
}

pub IdExpression = { "id" };

extern {
    type Location = usize;
    type Error = lexer::LexicalError;

    enum lexer::Tok {
        "\n" => lexer::Tok::Newline,
        "+=" => lexer::Tok::AddEq,
        "-=" => lexer::Tok::SubEq,
        "*=" => lexer::Tok::MulEq,
        "/=" => lexer::Tok::DivEq,
        "%=" => lexer::Tok::ModEq,
        "=" => lexer::Tok::Eq,
        "+" => lexer::Tok::Add,
        "-" => lexer::Tok::Sub,
        "*" => lexer::Tok::Mul,
        "/" => lexer::Tok::Div,
        "%" => lexer::Tok::Mod,
        "(" => lexer::Tok::POPEN,
        ")" => lexer::Tok::PCLOSE,
        "num" => lexer::Tok::Number(<i32>),
        "id" => lexer::Tok::Identifier(<String>),
        ":" => lexer::Tok::Colon,
        "," => lexer::Tok::Comma,
        "." => lexer::Tok::Dot,
    }
}
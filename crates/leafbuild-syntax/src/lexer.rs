/*
 *   Copyright (c) 2021 Dinu Blanovschi
 *   All rights reserved.
 *   Licensed under the terms of the BSD-3 Clause license, see LICENSE for more.
 */
// @generated by xtask generate-grammar
use crate::parser::Span;
use crate::syntax_kind::SyntaxKind;
use leafbuild_stdx::Let;
use logos::Logos;
use std::convert::TryInto;
use std::ops::Range;
#[derive(Logos, Copy, Clone, Debug, PartialEq, PartialOrd, Eq)]
pub enum Tk {
    #[regex(r#"[a-zA-Z_][a-zA-Z0-9_]*"#)]
    Id,
    #[regex(r#"([1-9][0-9]*|0x[0-9a-fA-F]+|0b[01]+|0[0-7]+|0)[uU]?[lL]?"#)]
    NumLit,
    #[regex(r#"'(\\['nt\\]|[^'\\])+'"#)]
    String,
    #[regex(r#"'''([^']*|'[^']|''[^'])*'''"#)]
    MultilineString,
    #[regex(r#"//[^\n]*"#)]
    SingleLineComment,
    #[regex(r#"/\*([^*]|\**[^*/])*\*+/"#)]
    BlockComment,
    #[regex(r#"[ \t\r]+"#)]
    Whitespace,
    #[token("+=")]
    PlusEq,
    #[token("-=")]
    MinusEq,
    #[token("*=")]
    MulEq,
    #[token("/=")]
    DivEq,
    #[token("%=")]
    ModEq,
    #[token("+")]
    Plus,
    #[token("-")]
    Minus,
    #[token("*")]
    Asterisk,
    #[token("/")]
    Slash,
    #[token("%")]
    Percent,
    #[token("==")]
    EqEq,
    #[token(">=")]
    GreaterEq,
    #[token(">")]
    Greater,
    #[token("<=")]
    LessEq,
    #[token("<")]
    Less,
    #[token("=")]
    Eq,
    #[token("!=")]
    NotEq,
    #[token("(")]
    LParen,
    #[token(")")]
    RParen,
    #[token("[")]
    LBrakcet,
    #[token("]")]
    RBracket,
    #[token("{")]
    LBrace,
    #[token("}")]
    RBrace,
    #[token(".")]
    Dot,
    #[token(":")]
    Colon,
    #[token("?")]
    QMark,
    #[token(";")]
    Semicolon,
    #[token(",")]
    Comma,
    #[token("and")]
    AndKw,
    #[token("or")]
    OrKw,
    #[token("not")]
    NotKw,
    #[token("in")]
    InKw,
    #[token("let")]
    LetKw,
    #[token("if")]
    IfKw,
    #[token("else")]
    ElseKw,
    #[token("foreach")]
    ForeachKw,
    #[token("continue")]
    ContinueKw,
    #[token("break")]
    BreakKw,
    #[token("return")]
    ReturnKw,
    #[token("true")]
    TrueKw,
    #[token("false")]
    FalseKw,
    #[token("fn")]
    FnKw,
    #[token("struct")]
    StructKw,
    #[token("\n")]
    Newline,
    #[error]
    #[regex(r"/\*([^*]|\*+[^*/])*\*?")]
    Error,
}
impl From<Tk> for SyntaxKind {
    fn from(tk: Tk) -> Self {
        use SyntaxKind::*;
        match tk {
            Tk::Id => ID,
            Tk::NumLit => NUM,
            Tk::String => STRING,
            Tk::MultilineString => MULTILINE_STRING,
            Tk::SingleLineComment => SINGLE_LINE_COMMENT,
            Tk::BlockComment => BLOCK_COMMENT,
            Tk::Whitespace => WHITESPACE,
            Tk::PlusEq => PLUS_EQ,
            Tk::MinusEq => MINUS_EQ,
            Tk::MulEq => MUL_EQ,
            Tk::DivEq => DIV_EQ,
            Tk::ModEq => MOD_EQ,
            Tk::Plus => PLUS,
            Tk::Minus => MINUS,
            Tk::Asterisk => ASTERISK,
            Tk::Slash => SLASH,
            Tk::Percent => PERCENT,
            Tk::EqEq => EQ_EQ,
            Tk::GreaterEq => GREATER_EQ,
            Tk::Greater => GREATER,
            Tk::LessEq => LESS_EQ,
            Tk::Less => LESS,
            Tk::Eq => EQ,
            Tk::NotEq => NEQ,
            Tk::LParen => L_PAREN,
            Tk::RParen => R_PAREN,
            Tk::LBrakcet => L_BRACKET,
            Tk::RBracket => R_BRACKET,
            Tk::LBrace => L_BRACE,
            Tk::RBrace => R_BRACE,
            Tk::Dot => DOT,
            Tk::Colon => COLON,
            Tk::QMark => QMARK,
            Tk::Semicolon => SEMICOLON,
            Tk::Comma => COMMA,
            Tk::AndKw => AND_KW,
            Tk::OrKw => OR_KW,
            Tk::NotKw => NOT_KW,
            Tk::InKw => IN_KW,
            Tk::LetKw => LET_KW,
            Tk::IfKw => IF_KW,
            Tk::ElseKw => ELSE_KW,
            Tk::ForeachKw => FOREACH_KW,
            Tk::ContinueKw => CONTINUE_KW,
            Tk::BreakKw => BREAK_KW,
            Tk::ReturnKw => RETURN_KW,
            Tk::TrueKw => TRUE_KW,
            Tk::FalseKw => FALSE_KW,
            Tk::FnKw => FN_KW,
            Tk::StructKw => STRUCT_KW,
            Tk::Newline => NEWLINE,
            Tk::Error => ERROR,
        }
    }
}
#[allow(missing_debug_implementations)]
pub struct Lexer<'a> {
    lexer: logos::Lexer<'a, Tk>,
}
impl<'a> Lexer<'a> {
    pub(crate) fn new(s: &'a str) -> Self {
        let lexer = Tk::lexer(s);
        Self { lexer }
    }
}
impl<'a> Iterator for Lexer<'a> {
    type Item = (SyntaxKind, &'a str, Span);
    fn next(&mut self) -> Option<Self::Item> {
        self.lexer.next().map(|token| {
            (
                token.into(),
                self.lexer.slice(),
                self.lexer
                    .span()
                    .let_(|it| -> Range<u32> {
                        it.start.try_into().unwrap()..it.end.try_into().unwrap()
                    })
                    .into(),
            )
        })
    }
}

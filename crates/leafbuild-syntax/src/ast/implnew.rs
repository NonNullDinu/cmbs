// @generated by xtask generate-grammar
#![allow(missing_docs)]
use crate::{
    ast::{support, AstChildren, AstNode, SyntaxNode, SyntaxToken},
    syntax_kind::SyntaxKind::{self, *},
    T,
};
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BuildDefinition {
    pub(crate) syntax: SyntaxNode,
}
impl BuildDefinition {
    pub fn lang_items(&self) -> AstChildren<LangItem> {
        support::children(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StmtWrap {
    pub(crate) syntax: SyntaxNode,
}
impl StmtWrap {
    pub fn stmt(&self) -> Option<Stmt> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructDecl {
    pub(crate) syntax: SyntaxNode,
}
impl StructDecl {
    pub fn struct_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![struct])
    }
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
    pub fn struct_field_list(&self) -> Option<StructFieldList> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct KExpr {
    pub(crate) syntax: SyntaxNode,
}
impl KExpr {
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T ! [=])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExprEvalStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ExprEvalStmt {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn newline_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![newline])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DeclarationStmt {
    pub(crate) syntax: SyntaxNode,
}
impl DeclarationStmt {
    pub fn let_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![let])
    }
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T ! [=])
    }
    pub fn newline_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![newline])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssignmentStmt {
    pub(crate) syntax: SyntaxNode,
}
impl AssignmentStmt {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForeachStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ForeachStmt {
    pub fn foreach_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![foreach])
    }
    pub fn foreach_in_expr(&self) -> Option<ForeachInExpr> {
        support::child(&self.syntax)
    }
    pub fn block(&self) -> Option<Block> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConditionalStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ConditionalStmt {
    pub fn conditional(&self) -> Option<Conditional> {
        support::child(&self.syntax)
    }
    pub fn newline_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![newline])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrimaryExpr {
    pub(crate) syntax: SyntaxNode,
}
impl PrimaryExpr {
    pub fn str_lit(&self) -> Option<StrLit> {
        support::child(&self.syntax)
    }
    pub fn float_number_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![float_number])
    }
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
    pub fn prefix_unary_expr(&self) -> Option<PrefixUnaryExpr> {
        support::child(&self.syntax)
    }
    pub fn bool_lit(&self) -> Option<BoolLit> {
        support::child(&self.syntax)
    }
    pub fn array_lit_expr(&self) -> Option<ArrayLitExpr> {
        support::child(&self.syntax)
    }
    pub fn map_lit_expr(&self) -> Option<MapLitExpr> {
        support::child(&self.syntax)
    }
    pub fn tuple_expr(&self) -> Option<TupleExpr> {
        support::child(&self.syntax)
    }
    pub fn conditional(&self) -> Option<Conditional> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinExpr {
    pub(crate) syntax: SyntaxNode,
}
impl BinExpr {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnCallExpr {
    pub(crate) syntax: SyntaxNode,
}
impl FnCallExpr {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn fn_call_args(&self) -> Option<FnCallArgs> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndexExpr {
    pub(crate) syntax: SyntaxNode,
}
impl IndexExpr {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn index_expr_brackets(&self) -> Option<IndexExprBrackets> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnCallArgs {
    pub(crate) syntax: SyntaxNode,
}
impl FnCallArgs {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn args(&self) -> AstChildren<FnArg> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndexExprBrackets {
    pub(crate) syntax: SyntaxNode,
}
impl IndexExprBrackets {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StrLit {
    pub(crate) syntax: SyntaxNode,
}
impl StrLit {
    pub fn str_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![str])
    }
    pub fn multiline_str_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![multiline_str])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixUnaryExpr {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixUnaryExpr {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BoolLit {
    pub(crate) syntax: SyntaxNode,
}
impl BoolLit {
    pub fn true_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![true])
    }
    pub fn false_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![false])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayLitExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ArrayLitExpr {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn exprs(&self) -> AstChildren<Expr> {
        support::children(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MapLitExpr {
    pub(crate) syntax: SyntaxNode,
}
impl MapLitExpr {
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn k_exprs(&self) -> AstChildren<KExpr> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleExpr {
    pub(crate) syntax: SyntaxNode,
}
impl TupleExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn fields(&self) -> AstChildren<Expr> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Conditional {
    pub(crate) syntax: SyntaxNode,
}
impl Conditional {
    pub fn if_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![if])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn block(&self) -> Option<Block> {
        support::child(&self.syntax)
    }
    pub fn else_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![else])
    }
    pub fn conditional(&self) -> Option<Conditional> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnArgExpr {
    pub(crate) syntax: SyntaxNode,
}
impl FnArgExpr {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Block {
    pub(crate) syntax: SyntaxNode,
}
impl Block {
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn statements(&self) -> AstChildren<Stmt> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ContinueStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ContinueStmt {
    pub fn continue_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![continue])
    }
    pub fn newline_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![newline])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BreakStmt {
    pub(crate) syntax: SyntaxNode,
}
impl BreakStmt {
    pub fn break_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![break])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn newline_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![newline])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReturnStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ReturnStmt {
    pub fn return_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![return])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn newline_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![newline])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForeachInExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ForeachInExpr {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn in_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![in])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructFieldList {
    pub(crate) syntax: SyntaxNode,
}
impl StructFieldList {
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn struct_fields(&self) -> AstChildren<StructField> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructField {
    pub(crate) syntax: SyntaxNode,
}
impl StructField {
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T ! [:])
    }
    pub fn type_ref(&self) -> Option<TypeRef> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeRef {
    pub(crate) syntax: SyntaxNode,
}
impl TypeRef {
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
    pub fn generic_params(&self) -> Option<GenericParams> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GenericParams {
    pub(crate) syntax: SyntaxNode,
}
impl GenericParams {
    pub fn l_angle_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T ! [<])
    }
    pub fn generic_params(&self) -> AstChildren<TypeRef> {
        support::children(&self.syntax)
    }
    pub fn r_angle_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T ! [>])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum LangItem {
    StmtWrap(StmtWrap),
    StructDecl(StructDecl),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expr {
    PrimaryExpr(PrimaryExpr),
    BinExpr(BinExpr),
    FnCallExpr(FnCallExpr),
    IndexExpr(IndexExpr),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Stmt {
    ExprEvalStmt(ExprEvalStmt),
    DeclarationStmt(DeclarationStmt),
    AssignmentStmt(AssignmentStmt),
    ForeachStmt(ForeachStmt),
    ConditionalStmt(ConditionalStmt),
    ControlStmt(ControlStmt),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ControlStmt {
    ContinueStmt(ContinueStmt),
    BreakStmt(BreakStmt),
    ReturnStmt(ReturnStmt),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum FnArg {
    KExpr(KExpr),
    FnArgExpr(FnArgExpr),
}
impl AstNode for BuildDefinition {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BUILD_DEFINITION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for StmtWrap {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STMT_WRAP
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for StructDecl {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STRUCT_DECL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for KExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == K_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ExprEvalStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == EXPR_EVAL_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DeclarationStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DECLARATION_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AssignmentStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ASSIGNMENT_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ForeachStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FOREACH_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ConditionalStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CONDITIONAL_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrimaryExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PRIMARY_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for BinExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BIN_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for FnCallExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FN_CALL_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IndexExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INDEX_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for FnCallArgs {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FN_CALL_ARGS
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IndexExprBrackets {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INDEX_EXPR_BRACKETS
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for StrLit {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STR_LIT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixUnaryExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_UNARY_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for BoolLit {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BOOL_LIT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ArrayLitExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ARRAY_LIT_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MapLitExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MAP_LIT_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TupleExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TUPLE_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Conditional {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CONDITIONAL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for FnArgExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FN_ARG_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Block {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BLOCK
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ContinueStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CONTINUE_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for BreakStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BREAK_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ReturnStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == RETURN_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ForeachInExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FOREACH_IN_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for StructFieldList {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STRUCT_FIELD_LIST
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for StructField {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STRUCT_FIELD
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TypeRef {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TYPE_REF
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for GenericParams {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == GENERIC_PARAMS
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl From<StmtWrap> for LangItem {
    fn from(node: StmtWrap) -> LangItem {
        LangItem::StmtWrap(node)
    }
}
impl From<StructDecl> for LangItem {
    fn from(node: StructDecl) -> LangItem {
        LangItem::StructDecl(node)
    }
}
impl AstNode for LangItem {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            STMT_WRAP | STRUCT_DECL => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            STMT_WRAP => LangItem::StmtWrap(StmtWrap { syntax }),
            STRUCT_DECL => LangItem::StructDecl(StructDecl { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            LangItem::StmtWrap(it) => &it.syntax,
            LangItem::StructDecl(it) => &it.syntax,
        }
    }
}
impl From<PrimaryExpr> for Expr {
    fn from(node: PrimaryExpr) -> Expr {
        Expr::PrimaryExpr(node)
    }
}
impl From<BinExpr> for Expr {
    fn from(node: BinExpr) -> Expr {
        Expr::BinExpr(node)
    }
}
impl From<FnCallExpr> for Expr {
    fn from(node: FnCallExpr) -> Expr {
        Expr::FnCallExpr(node)
    }
}
impl From<IndexExpr> for Expr {
    fn from(node: IndexExpr) -> Expr {
        Expr::IndexExpr(node)
    }
}
impl AstNode for Expr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PRIMARY_EXPR | BIN_EXPR | FN_CALL_EXPR | INDEX_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            PRIMARY_EXPR => Expr::PrimaryExpr(PrimaryExpr { syntax }),
            BIN_EXPR => Expr::BinExpr(BinExpr { syntax }),
            FN_CALL_EXPR => Expr::FnCallExpr(FnCallExpr { syntax }),
            INDEX_EXPR => Expr::IndexExpr(IndexExpr { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Expr::PrimaryExpr(it) => &it.syntax,
            Expr::BinExpr(it) => &it.syntax,
            Expr::FnCallExpr(it) => &it.syntax,
            Expr::IndexExpr(it) => &it.syntax,
        }
    }
}
impl From<ExprEvalStmt> for Stmt {
    fn from(node: ExprEvalStmt) -> Stmt {
        Stmt::ExprEvalStmt(node)
    }
}
impl From<DeclarationStmt> for Stmt {
    fn from(node: DeclarationStmt) -> Stmt {
        Stmt::DeclarationStmt(node)
    }
}
impl From<AssignmentStmt> for Stmt {
    fn from(node: AssignmentStmt) -> Stmt {
        Stmt::AssignmentStmt(node)
    }
}
impl From<ForeachStmt> for Stmt {
    fn from(node: ForeachStmt) -> Stmt {
        Stmt::ForeachStmt(node)
    }
}
impl From<ConditionalStmt> for Stmt {
    fn from(node: ConditionalStmt) -> Stmt {
        Stmt::ConditionalStmt(node)
    }
}
impl From<ControlStmt> for Stmt {
    fn from(node: ControlStmt) -> Stmt {
        Stmt::ControlStmt(node)
    }
}
impl From<ContinueStmt> for ControlStmt {
    fn from(node: ContinueStmt) -> ControlStmt {
        ControlStmt::ContinueStmt(node)
    }
}
impl From<BreakStmt> for ControlStmt {
    fn from(node: BreakStmt) -> ControlStmt {
        ControlStmt::BreakStmt(node)
    }
}
impl From<ReturnStmt> for ControlStmt {
    fn from(node: ReturnStmt) -> ControlStmt {
        ControlStmt::ReturnStmt(node)
    }
}
impl AstNode for ControlStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            CONTINUE_STMT | BREAK_STMT | RETURN_STMT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            CONTINUE_STMT => ControlStmt::ContinueStmt(ContinueStmt { syntax }),
            BREAK_STMT => ControlStmt::BreakStmt(BreakStmt { syntax }),
            RETURN_STMT => ControlStmt::ReturnStmt(ReturnStmt { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            ControlStmt::ContinueStmt(it) => &it.syntax,
            ControlStmt::BreakStmt(it) => &it.syntax,
            ControlStmt::ReturnStmt(it) => &it.syntax,
        }
    }
}
impl From<KExpr> for FnArg {
    fn from(node: KExpr) -> FnArg {
        FnArg::KExpr(node)
    }
}
impl From<FnArgExpr> for FnArg {
    fn from(node: FnArgExpr) -> FnArg {
        FnArg::FnArgExpr(node)
    }
}
impl AstNode for FnArg {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            K_EXPR | FN_ARG_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            K_EXPR => FnArg::KExpr(KExpr { syntax }),
            FN_ARG_EXPR => FnArg::FnArgExpr(FnArgExpr { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            FnArg::KExpr(it) => &it.syntax,
            FnArg::FnArgExpr(it) => &it.syntax,
        }
    }
}
impl std::fmt::Display for LangItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Expr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Stmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ControlStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FnArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BuildDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StmtWrap {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for KExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExprEvalStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DeclarationStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssignmentStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ForeachStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ConditionalStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrimaryExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BinExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FnCallExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IndexExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FnCallArgs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IndexExprBrackets {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StrLit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixUnaryExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BoolLit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ArrayLitExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MapLitExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TupleExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Conditional {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FnArgExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Block {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ContinueStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BreakStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ReturnStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ForeachInExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructFieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for GenericParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}

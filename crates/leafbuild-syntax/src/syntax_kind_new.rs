// @generated by xtask generate-grammar
#![allow(bad_style, missing_docs, unreachable_pub)]
#[doc = r" The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT`."]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
#[repr(u16)]
pub enum SyntaxKind {
    #[doc(hidden)]
    TOMBSTONE,
    #[doc(hidden)]
    EOF,
    COMMA,
    PLUS,
    MINUS,
    SLASH,
    STAR,
    PERCENT,
    L_PAREN,
    R_PAREN,
    L_CURLY,
    R_CURLY,
    L_BRACKET,
    R_BRACKET,
    L_ANGLE,
    R_ANGLE,
    EQ,
    BANG,
    EQEQ,
    NOT_EQ,
    GREATER_EQ,
    LESSTHAN_EQ,
    PLUS_EQ,
    MINUS_EQ,
    STAR_EQ,
    SLASH_EQ,
    PERCENT_EQ,
    AMP_AMP,
    PIPE2,
    SEMICOLON,
    COLON,
    QMARK,
    DOT,
    LET_KW,
    IF_KW,
    ELSE_KW,
    FOREACH_KW,
    STRUCT_KW,
    FN_KW,
    BREAK_KW,
    CONTINUE_KW,
    RETURN_KW,
    TRUE_KW,
    FALSE_KW,
    AND_KW,
    OR_KW,
    NOT_KW,
    IN_KW,
    INT_NUMBER,
    FLOAT_NUMBER,
    STR,
    MULTILINE_STR,
    ERROR,
    IDENT,
    WHITESPACE,
    COMMENT,
    NEWLINE,
    BLOCK_COMMENT,
    SHEBANG,
    BUILD_DEFINITION,
    K_EXPR,
    STMT_WRAP,
    FN_CALL_EXPR,
    INDEX_EXPR,
    STR_LIT,
    PRIMARY_EXPR,
    PREFIX_UNARY_EXPR,
    ARRAY_LIT_EXPR,
    MAP_LIT_EXPR,
    TUPLE_EXPR,
    BOOL_LIT,
    FN_ARG_EXPR,
    FN_CALL_ARGS,
    INDEX_EXPR_BRACKETS,
    BIN_EXPR,
    CONDITIONAL,
    CONDITIONAL_STMT,
    BLOCK,
    EXPR_EVAL_STMT,
    ASSIGNMENT_STMT,
    DECLARATION_STMT,
    CONTINUE_STMT,
    BREAK_STMT,
    RETURN_STMT,
    FOREACH_STMT,
    FOREACH_IN_EXPR,
    STRUCT_DECL,
    STRUCT_FIELD_LIST,
    STRUCT_FIELD,
    TYPE_REF,
    GENERIC_PARAMS,
    #[doc(hidden)]
    __LAST,
}
use self::SyntaxKind::*;
impl SyntaxKind {
    pub fn is_keyword(self) -> bool {
        match self {
            LET_KW | IF_KW | ELSE_KW | FOREACH_KW | STRUCT_KW | FN_KW | BREAK_KW | CONTINUE_KW
            | RETURN_KW | TRUE_KW | FALSE_KW | AND_KW | OR_KW | NOT_KW | IN_KW => true,
            _ => false,
        }
    }
    pub fn is_punct(self) -> bool {
        match self {
            COMMA | PLUS | MINUS | SLASH | STAR | PERCENT | L_PAREN | R_PAREN | L_CURLY
            | R_CURLY | L_BRACKET | R_BRACKET | L_ANGLE | R_ANGLE | EQ | BANG | EQEQ | NOT_EQ
            | GREATER_EQ | LESSTHAN_EQ | PLUS_EQ | MINUS_EQ | STAR_EQ | SLASH_EQ | PERCENT_EQ
            | AMP_AMP | PIPE2 | SEMICOLON | COLON | QMARK | DOT => true,
            _ => false,
        }
    }
    pub fn is_literal(self) -> bool {
        match self {
            INT_NUMBER | FLOAT_NUMBER | STR | MULTILINE_STR => true,
            _ => false,
        }
    }
    pub fn from_keyword(ident: &str) -> Option<SyntaxKind> {
        let kw = match ident {
            "let" => LET_KW,
            "if" => IF_KW,
            "else" => ELSE_KW,
            "foreach" => FOREACH_KW,
            "struct" => STRUCT_KW,
            "fn" => FN_KW,
            "break" => BREAK_KW,
            "continue" => CONTINUE_KW,
            "return" => RETURN_KW,
            "true" => TRUE_KW,
            "false" => FALSE_KW,
            "and" => AND_KW,
            "or" => OR_KW,
            "not" => NOT_KW,
            "in" => IN_KW,
            _ => return None,
        };
        Some(kw)
    }
    pub fn from_char(c: char) -> Option<SyntaxKind> {
        let tok = match c {
            ',' => COMMA,
            '+' => PLUS,
            '-' => MINUS,
            '/' => SLASH,
            '*' => STAR,
            '%' => PERCENT,
            '(' => L_PAREN,
            ')' => R_PAREN,
            '{' => L_CURLY,
            '}' => R_CURLY,
            '[' => L_BRACKET,
            ']' => R_BRACKET,
            '<' => L_ANGLE,
            '>' => R_ANGLE,
            '=' => EQ,
            '!' => BANG,
            ';' => SEMICOLON,
            ':' => COLON,
            '?' => QMARK,
            '.' => DOT,
            _ => return None,
        };
        Some(tok)
    }
}
#[macro_export]
#[doc = "A nice way of getting syntax kinds from tokens"]
macro_rules ! T { [,] => { $ crate :: SyntaxKind :: COMMA } ; [+] => { $ crate :: SyntaxKind :: PLUS } ; [-] => { $ crate :: SyntaxKind :: MINUS } ; [/] => { $ crate :: SyntaxKind :: SLASH } ; [*] => { $ crate :: SyntaxKind :: STAR } ; [%] => { $ crate :: SyntaxKind :: PERCENT } ; ['('] => { $ crate :: SyntaxKind :: L_PAREN } ; [')'] => { $ crate :: SyntaxKind :: R_PAREN } ; ['{'] => { $ crate :: SyntaxKind :: L_CURLY } ; ['}'] => { $ crate :: SyntaxKind :: R_CURLY } ; ['['] => { $ crate :: SyntaxKind :: L_BRACKET } ; [']'] => { $ crate :: SyntaxKind :: R_BRACKET } ; [<] => { $ crate :: SyntaxKind :: L_ANGLE } ; [>] => { $ crate :: SyntaxKind :: R_ANGLE } ; [=] => { $ crate :: SyntaxKind :: EQ } ; [!] => { $ crate :: SyntaxKind :: BANG } ; [==] => { $ crate :: SyntaxKind :: EQEQ } ; [!=] => { $ crate :: SyntaxKind :: NOT_EQ } ; [>=] => { $ crate :: SyntaxKind :: GREATER_EQ } ; [<=] => { $ crate :: SyntaxKind :: LESSTHAN_EQ } ; [+=] => { $ crate :: SyntaxKind :: PLUS_EQ } ; [-=] => { $ crate :: SyntaxKind :: MINUS_EQ } ; [*=] => { $ crate :: SyntaxKind :: STAR_EQ } ; [/=] => { $ crate :: SyntaxKind :: SLASH_EQ } ; [%=] => { $ crate :: SyntaxKind :: PERCENT_EQ } ; [&&] => { $ crate :: SyntaxKind :: AMP_AMP } ; [||] => { $ crate :: SyntaxKind :: PIPE2 } ; [;] => { $ crate :: SyntaxKind :: SEMICOLON } ; [:] => { $ crate :: SyntaxKind :: COLON } ; [?] => { $ crate :: SyntaxKind :: QMARK } ; [.] => { $ crate :: SyntaxKind :: DOT } ; [let] => { $ crate :: SyntaxKind :: LET_KW } ; [if] => { $ crate :: SyntaxKind :: IF_KW } ; [else] => { $ crate :: SyntaxKind :: ELSE_KW } ; [foreach] => { $ crate :: SyntaxKind :: FOREACH_KW } ; [struct] => { $ crate :: SyntaxKind :: STRUCT_KW } ; [fn] => { $ crate :: SyntaxKind :: FN_KW } ; [break] => { $ crate :: SyntaxKind :: BREAK_KW } ; [continue] => { $ crate :: SyntaxKind :: CONTINUE_KW } ; [return] => { $ crate :: SyntaxKind :: RETURN_KW } ; [true] => { $ crate :: SyntaxKind :: TRUE_KW } ; [false] => { $ crate :: SyntaxKind :: FALSE_KW } ; [and] => { $ crate :: SyntaxKind :: AND_KW } ; [or] => { $ crate :: SyntaxKind :: OR_KW } ; [not] => { $ crate :: SyntaxKind :: NOT_KW } ; [in] => { $ crate :: SyntaxKind :: IN_KW } ; [ident] => { $ crate :: SyntaxKind :: IDENT } ; [newline] => { $ crate :: SyntaxKind :: NEWLINE } ; [int_number] => { $ crate :: SyntaxKind :: INT_NUMBER } ; [float_number] => { $ crate :: SyntaxKind :: FLOAT_NUMBER } ; [str] => { $ crate :: SyntaxKind :: STR } ; [multiline_str] => { $ crate :: SyntaxKind :: MULTILINE_STR } ; [comment] => { $ crate :: SyntaxKind :: COMMENT } ; [block_comment] => { $ crate :: SyntaxKind :: BLOCK_COMMENT } ; [whitespace] => { $ crate :: SyntaxKind :: WHITESPACE } ; [not] => { $ crate :: SyntaxKind :: NOT_KW } ; [shebang] => { $ crate :: SyntaxKind :: SHEBANG } ; }

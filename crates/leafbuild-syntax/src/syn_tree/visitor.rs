// @generated by xtask generate-grammar
use super::{
    implementation::*, AstNode, AstToken, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken,
};
#[doc = "The visitor trait"]
pub trait Visitor {
    type Output;
    type Sink;
    #[doc = "Visits a Id token"]
    fn visit_id(&self, id: Id) -> Self::Output;
    #[doc = "Visits a NumLit token"]
    fn visit_num_lit(&self, num_lit: NumLit) -> Self::Output;
    #[doc = "Visits a Str token"]
    fn visit_str(&self, str: Str) -> Self::Output;
    #[doc = "Visits a MultilineStr token"]
    fn visit_multiline_str(&self, multiline_str: MultilineStr) -> Self::Output;
    #[doc = "Visits a SingleLineComment token"]
    fn visit_single_line_comment(&self, single_line_comment: SingleLineComment) -> Self::Output;
    #[doc = "Visits a BlockComment token"]
    fn visit_block_comment(&self, block_comment: BlockComment) -> Self::Output;
    #[doc = "Visits a Whitespace token"]
    fn visit_whitespace(&self, whitespace: Whitespace) -> Self::Output;
    #[doc = "Visits a PlusEq token"]
    fn visit_plus_eq(&self, plus_eq: PlusEq) -> Self::Output;
    #[doc = "Visits a MinusEq token"]
    fn visit_minus_eq(&self, minus_eq: MinusEq) -> Self::Output;
    #[doc = "Visits a MulEq token"]
    fn visit_mul_eq(&self, mul_eq: MulEq) -> Self::Output;
    #[doc = "Visits a DivEq token"]
    fn visit_div_eq(&self, div_eq: DivEq) -> Self::Output;
    #[doc = "Visits a ModEq token"]
    fn visit_mod_eq(&self, mod_eq: ModEq) -> Self::Output;
    #[doc = "Visits a Plus token"]
    fn visit_plus(&self, plus: Plus) -> Self::Output;
    #[doc = "Visits a Minus token"]
    fn visit_minus(&self, minus: Minus) -> Self::Output;
    #[doc = "Visits a Asterisk token"]
    fn visit_asterisk(&self, asterisk: Asterisk) -> Self::Output;
    #[doc = "Visits a Slash token"]
    fn visit_slash(&self, slash: Slash) -> Self::Output;
    #[doc = "Visits a Percent token"]
    fn visit_percent(&self, percent: Percent) -> Self::Output;
    #[doc = "Visits a EqEq token"]
    fn visit_eq_eq(&self, eq_eq: EqEq) -> Self::Output;
    #[doc = "Visits a GreaterEq token"]
    fn visit_greater_eq(&self, greater_eq: GreaterEq) -> Self::Output;
    #[doc = "Visits a Greater token"]
    fn visit_greater(&self, greater: Greater) -> Self::Output;
    #[doc = "Visits a LessEq token"]
    fn visit_less_eq(&self, less_eq: LessEq) -> Self::Output;
    #[doc = "Visits a Less token"]
    fn visit_less(&self, less: Less) -> Self::Output;
    #[doc = "Visits a Eq token"]
    fn visit_eq(&self, eq: Eq) -> Self::Output;
    #[doc = "Visits a NotEq token"]
    fn visit_not_eq(&self, not_eq: NotEq) -> Self::Output;
    #[doc = "Visits a LParen token"]
    fn visit_lparen(&self, lparen: LParen) -> Self::Output;
    #[doc = "Visits a RParen token"]
    fn visit_rparen(&self, rparen: RParen) -> Self::Output;
    #[doc = "Visits a LBracket token"]
    fn visit_lbracket(&self, lbracket: LBracket) -> Self::Output;
    #[doc = "Visits a RBracket token"]
    fn visit_rbracket(&self, rbracket: RBracket) -> Self::Output;
    #[doc = "Visits a LBrace token"]
    fn visit_lbrace(&self, lbrace: LBrace) -> Self::Output;
    #[doc = "Visits a RBrace token"]
    fn visit_rbrace(&self, rbrace: RBrace) -> Self::Output;
    #[doc = "Visits a Dot token"]
    fn visit_dot(&self, dot: Dot) -> Self::Output;
    #[doc = "Visits a Colon token"]
    fn visit_colon(&self, colon: Colon) -> Self::Output;
    #[doc = "Visits a QMark token"]
    fn visit_qmark(&self, qmark: QMark) -> Self::Output;
    #[doc = "Visits a Semicolon token"]
    fn visit_semicolon(&self, semicolon: Semicolon) -> Self::Output;
    #[doc = "Visits a Comma token"]
    fn visit_comma(&self, comma: Comma) -> Self::Output;
    #[doc = "Visits a AndKw token"]
    fn visit_and_kw(&self, and_kw: AndKw) -> Self::Output;
    #[doc = "Visits a OrKw token"]
    fn visit_or_kw(&self, or_kw: OrKw) -> Self::Output;
    #[doc = "Visits a NotKw token"]
    fn visit_not_kw(&self, not_kw: NotKw) -> Self::Output;
    #[doc = "Visits a InKw token"]
    fn visit_in_kw(&self, in_kw: InKw) -> Self::Output;
    #[doc = "Visits a LetKw token"]
    fn visit_let_kw(&self, let_kw: LetKw) -> Self::Output;
    #[doc = "Visits a IfKw token"]
    fn visit_if_kw(&self, if_kw: IfKw) -> Self::Output;
    #[doc = "Visits a ElseKw token"]
    fn visit_else_kw(&self, else_kw: ElseKw) -> Self::Output;
    #[doc = "Visits a ForeachKw token"]
    fn visit_foreach_kw(&self, foreach_kw: ForeachKw) -> Self::Output;
    #[doc = "Visits a ContinueKw token"]
    fn visit_continue_kw(&self, continue_kw: ContinueKw) -> Self::Output;
    #[doc = "Visits a BreakKw token"]
    fn visit_break_kw(&self, break_kw: BreakKw) -> Self::Output;
    #[doc = "Visits a ReturnKw token"]
    fn visit_return_kw(&self, return_kw: ReturnKw) -> Self::Output;
    #[doc = "Visits a TrueKw token"]
    fn visit_true_kw(&self, true_kw: TrueKw) -> Self::Output;
    #[doc = "Visits a FalseKw token"]
    fn visit_false_kw(&self, false_kw: FalseKw) -> Self::Output;
    #[doc = "Visits a FnKw token"]
    fn visit_fn_kw(&self, fn_kw: FnKw) -> Self::Output;
    #[doc = "Visits a StructKw token"]
    fn visit_struct_kw(&self, struct_kw: StructKw) -> Self::Output;
    #[doc = "Visits a Newline token"]
    fn visit_newline(&self, newline: Newline) -> Self::Output;
    #[doc = "Visits a Expr node"]
    fn visit_expr(&self, expr: Expr) -> Self::Output;
    #[doc = "Visits a ExprBlock node"]
    fn visit_expr_block(&self, expr_block: ExprBlock) -> Self::Output;
    #[doc = "Visits a KExpr node"]
    fn visit_kexpr(&self, kexpr: KExpr) -> Self::Output;
    #[doc = "Visits a ArrayLitExpr node"]
    fn visit_array_lit_expr(&self, array_lit_expr: ArrayLitExpr) -> Self::Output;
    #[doc = "Visits a MapLitExpr node"]
    fn visit_map_lit_expr(&self, map_lit_expr: MapLitExpr) -> Self::Output;
    #[doc = "Visits a StrLit node"]
    fn visit_str_lit(&self, str_lit: StrLit) -> Self::Output;
    #[doc = "Visits a PrimaryExpr node"]
    fn visit_primary_expr(&self, primary_expr: PrimaryExpr) -> Self::Output;
    #[doc = "Visits a PrefixUnaryOpExpr node"]
    fn visit_prefix_unary_op_expr(&self, prefix_unary_op_expr: PrefixUnaryOpExpr) -> Self::Output;
    #[doc = "Visits a InfixBinaryOpExpr node"]
    fn visit_infix_binary_op_expr(&self, infix_binary_op_expr: InfixBinaryOpExpr) -> Self::Output;
    #[doc = "Visits a FnCallExpr node"]
    fn visit_fn_call_expr(&self, fn_call_expr: FnCallExpr) -> Self::Output;
    #[doc = "Visits a FnCallArgsList node"]
    fn visit_fn_call_args_list(&self, fn_call_args_list: FnCallArgsList) -> Self::Output;
    #[doc = "Visits a FArg node"]
    fn visit_farg(&self, farg: FArg) -> Self::Output;
    #[doc = "Visits a TupleExpr node"]
    fn visit_tuple_expr(&self, tuple_expr: TupleExpr) -> Self::Output;
    #[doc = "Visits a BoolLit node"]
    fn visit_bool_lit(&self, bool_lit: BoolLit) -> Self::Output;
    #[doc = "Visits a IndexExpr node"]
    fn visit_index_expr(&self, index_expr: IndexExpr) -> Self::Output;
    #[doc = "Visits a IndexExprBrackets node"]
    fn visit_index_expr_brackets(&self, index_expr_brackets: IndexExprBrackets) -> Self::Output;
    #[doc = "Visits a Assignment node"]
    fn visit_assignment(&self, assignment: Assignment) -> Self::Output;
    #[doc = "Visits a Declaration node"]
    fn visit_declaration(&self, declaration: Declaration) -> Self::Output;
    #[doc = "Visits a Conditional node"]
    fn visit_conditional(&self, conditional: Conditional) -> Self::Output;
    #[doc = "Visits a Foreach node"]
    fn visit_foreach(&self, foreach: Foreach) -> Self::Output;
    #[doc = "Visits a ForInExpr node"]
    fn visit_for_in_expr(&self, for_in_expr: ForInExpr) -> Self::Output;
    #[doc = "Visits a ControlStatement node"]
    fn visit_control_statement(&self, control_statement: ControlStatement) -> Self::Output;
    #[doc = "Visits a ExprStatement node"]
    fn visit_expr_statement(&self, expr_statement: ExprStatement) -> Self::Output;
    #[doc = "Visits a Tuple node"]
    fn visit_tuple(&self, tuple: Tuple) -> Self::Output;
    #[doc = "Visits a ConditionalBranch node"]
    fn visit_conditional_branch(&self, conditional_branch: ConditionalBranch) -> Self::Output;
    #[doc = "Visits a Statement node"]
    fn visit_statement(&self, statement: Statement) -> Self::Output;
    #[doc = "Visits a StructDecl node"]
    fn visit_struct_decl(&self, struct_decl: StructDecl) -> Self::Output;
    #[doc = "Visits a StructFieldList node"]
    fn visit_struct_field_list(&self, struct_field_list: StructFieldList) -> Self::Output;
    #[doc = "Visits a StructField node"]
    fn visit_struct_field(&self, struct_field: StructField) -> Self::Output;
    #[doc = "Visits a TypeRef node"]
    fn visit_type_ref(&self, type_ref: TypeRef) -> Self::Output;
    #[doc = "Visits a TypeRefGenerics node"]
    fn visit_type_ref_generics(&self, type_ref_generics: TypeRefGenerics) -> Self::Output;
    #[doc = "Visits a LangItem node"]
    fn visit_lang_item(&self, lang_item: LangItem) -> Self::Output;
    #[doc = "Visits a Root node"]
    fn visit_root(&self, root: Root) -> Self::Output;
    #[allow(unsafe_code)]
    fn visit(&self, node: SyntaxNode) -> Self::Output {
        match node.kind() {
            SyntaxKind::Expr => self.visit_expr(unsafe { Expr::new(node) }),
            SyntaxKind::ExprBlock => self.visit_expr_block(unsafe { ExprBlock::new(node) }),
            SyntaxKind::KExpr => self.visit_kexpr(unsafe { KExpr::new(node) }),
            SyntaxKind::ArrayLitExpr => {
                self.visit_array_lit_expr(unsafe { ArrayLitExpr::new(node) })
            }
            SyntaxKind::MapLitExpr => self.visit_map_lit_expr(unsafe { MapLitExpr::new(node) }),
            SyntaxKind::StrLit => self.visit_str_lit(unsafe { StrLit::new(node) }),
            SyntaxKind::PrimaryExpr => self.visit_primary_expr(unsafe { PrimaryExpr::new(node) }),
            SyntaxKind::PrefixUnaryOpExpr => {
                self.visit_prefix_unary_op_expr(unsafe { PrefixUnaryOpExpr::new(node) })
            }
            SyntaxKind::InfixBinOpExpr => {
                self.visit_infix_binary_op_expr(unsafe { InfixBinaryOpExpr::new(node) })
            }
            SyntaxKind::FnCallExpr => self.visit_fn_call_expr(unsafe { FnCallExpr::new(node) }),
            SyntaxKind::FnCallArgsList => {
                self.visit_fn_call_args_list(unsafe { FnCallArgsList::new(node) })
            }
            SyntaxKind::FArg => self.visit_farg(unsafe { FArg::new(node) }),
            SyntaxKind::TupleExpr => self.visit_tuple_expr(unsafe { TupleExpr::new(node) }),
            SyntaxKind::BoolLit => self.visit_bool_lit(unsafe { BoolLit::new(node) }),
            SyntaxKind::IndexExpr => self.visit_index_expr(unsafe { IndexExpr::new(node) }),
            SyntaxKind::IndexExprBrackets => {
                self.visit_index_expr_brackets(unsafe { IndexExprBrackets::new(node) })
            }
            SyntaxKind::Assignment => self.visit_assignment(unsafe { Assignment::new(node) }),
            SyntaxKind::Declaration => self.visit_declaration(unsafe { Declaration::new(node) }),
            SyntaxKind::Conditional => self.visit_conditional(unsafe { Conditional::new(node) }),
            SyntaxKind::Foreach => self.visit_foreach(unsafe { Foreach::new(node) }),
            SyntaxKind::ForInExpr => self.visit_for_in_expr(unsafe { ForInExpr::new(node) }),
            SyntaxKind::ControlStatement => {
                self.visit_control_statement(unsafe { ControlStatement::new(node) })
            }
            SyntaxKind::ExprStatement => {
                self.visit_expr_statement(unsafe { ExprStatement::new(node) })
            }
            SyntaxKind::Tuple => self.visit_tuple(unsafe { Tuple::new(node) }),
            SyntaxKind::ConditionalBranch => {
                self.visit_conditional_branch(unsafe { ConditionalBranch::new(node) })
            }
            SyntaxKind::Statement => self.visit_statement(unsafe { Statement::new(node) }),
            SyntaxKind::StructDecl => self.visit_struct_decl(unsafe { StructDecl::new(node) }),
            SyntaxKind::StructFieldList => {
                self.visit_struct_field_list(unsafe { StructFieldList::new(node) })
            }
            SyntaxKind::StructField => self.visit_struct_field(unsafe { StructField::new(node) }),
            SyntaxKind::TypeRef => self.visit_type_ref(unsafe { TypeRef::new(node) }),
            SyntaxKind::TypeRefGenerics => {
                self.visit_type_ref_generics(unsafe { TypeRefGenerics::new(node) })
            }
            SyntaxKind::LangItem => self.visit_lang_item(unsafe { LangItem::new(node) }),
            SyntaxKind::ROOT => self.visit_root(unsafe { Root::new(node) }),
            _ => unreachable!(),
        }
    }
    #[allow(unsafe_code)]
    fn visit_token(&self, token: SyntaxToken) -> Self::Output {
        match token.kind() {
            SyntaxKind::ID => self.visit_id(unsafe { Id::new(token) }),
            SyntaxKind::NUM => self.visit_num_lit(unsafe { NumLit::new(token) }),
            SyntaxKind::STRING => self.visit_str(unsafe { Str::new(token) }),
            SyntaxKind::MULTILINE_STRING => {
                self.visit_multiline_str(unsafe { MultilineStr::new(token) })
            }
            SyntaxKind::SINGLE_LINE_COMMENT => {
                self.visit_single_line_comment(unsafe { SingleLineComment::new(token) })
            }
            SyntaxKind::BLOCK_COMMENT => {
                self.visit_block_comment(unsafe { BlockComment::new(token) })
            }
            SyntaxKind::WHITESPACE => self.visit_whitespace(unsafe { Whitespace::new(token) }),
            SyntaxKind::PLUS_EQ => self.visit_plus_eq(unsafe { PlusEq::new(token) }),
            SyntaxKind::MINUS_EQ => self.visit_minus_eq(unsafe { MinusEq::new(token) }),
            SyntaxKind::MUL_EQ => self.visit_mul_eq(unsafe { MulEq::new(token) }),
            SyntaxKind::DIV_EQ => self.visit_div_eq(unsafe { DivEq::new(token) }),
            SyntaxKind::MOD_EQ => self.visit_mod_eq(unsafe { ModEq::new(token) }),
            SyntaxKind::PLUS => self.visit_plus(unsafe { Plus::new(token) }),
            SyntaxKind::MINUS => self.visit_minus(unsafe { Minus::new(token) }),
            SyntaxKind::ASTERISK => self.visit_asterisk(unsafe { Asterisk::new(token) }),
            SyntaxKind::SLASH => self.visit_slash(unsafe { Slash::new(token) }),
            SyntaxKind::PERCENT => self.visit_percent(unsafe { Percent::new(token) }),
            SyntaxKind::EQ_EQ => self.visit_eq_eq(unsafe { EqEq::new(token) }),
            SyntaxKind::GREATER_EQ => self.visit_greater_eq(unsafe { GreaterEq::new(token) }),
            SyntaxKind::GREATER => self.visit_greater(unsafe { Greater::new(token) }),
            SyntaxKind::LESS_EQ => self.visit_less_eq(unsafe { LessEq::new(token) }),
            SyntaxKind::LESS => self.visit_less(unsafe { Less::new(token) }),
            SyntaxKind::EQ => self.visit_eq(unsafe { Eq::new(token) }),
            SyntaxKind::NEQ => self.visit_not_eq(unsafe { NotEq::new(token) }),
            SyntaxKind::L_PAREN => self.visit_lparen(unsafe { LParen::new(token) }),
            SyntaxKind::R_PAREN => self.visit_rparen(unsafe { RParen::new(token) }),
            SyntaxKind::L_BRACKET => self.visit_lbracket(unsafe { LBracket::new(token) }),
            SyntaxKind::R_BRACKET => self.visit_rbracket(unsafe { RBracket::new(token) }),
            SyntaxKind::L_BRACE => self.visit_lbrace(unsafe { LBrace::new(token) }),
            SyntaxKind::R_BRACE => self.visit_rbrace(unsafe { RBrace::new(token) }),
            SyntaxKind::DOT => self.visit_dot(unsafe { Dot::new(token) }),
            SyntaxKind::COLON => self.visit_colon(unsafe { Colon::new(token) }),
            SyntaxKind::QMARK => self.visit_qmark(unsafe { QMark::new(token) }),
            SyntaxKind::SEMICOLON => self.visit_semicolon(unsafe { Semicolon::new(token) }),
            SyntaxKind::COMMA => self.visit_comma(unsafe { Comma::new(token) }),
            SyntaxKind::AND_KW => self.visit_and_kw(unsafe { AndKw::new(token) }),
            SyntaxKind::OR_KW => self.visit_or_kw(unsafe { OrKw::new(token) }),
            SyntaxKind::NOT_KW => self.visit_not_kw(unsafe { NotKw::new(token) }),
            SyntaxKind::IN_KW => self.visit_in_kw(unsafe { InKw::new(token) }),
            SyntaxKind::LET_KW => self.visit_let_kw(unsafe { LetKw::new(token) }),
            SyntaxKind::IF_KW => self.visit_if_kw(unsafe { IfKw::new(token) }),
            SyntaxKind::ELSE_KW => self.visit_else_kw(unsafe { ElseKw::new(token) }),
            SyntaxKind::FOREACH_KW => self.visit_foreach_kw(unsafe { ForeachKw::new(token) }),
            SyntaxKind::CONTINUE_KW => self.visit_continue_kw(unsafe { ContinueKw::new(token) }),
            SyntaxKind::BREAK_KW => self.visit_break_kw(unsafe { BreakKw::new(token) }),
            SyntaxKind::RETURN_KW => self.visit_return_kw(unsafe { ReturnKw::new(token) }),
            SyntaxKind::TRUE_KW => self.visit_true_kw(unsafe { TrueKw::new(token) }),
            SyntaxKind::FALSE_KW => self.visit_false_kw(unsafe { FalseKw::new(token) }),
            SyntaxKind::FN_KW => self.visit_fn_kw(unsafe { FnKw::new(token) }),
            SyntaxKind::STRUCT_KW => self.visit_struct_kw(unsafe { StructKw::new(token) }),
            SyntaxKind::NEWLINE => self.visit_newline(unsafe { Newline::new(token) }),
            _ => unreachable!(),
        }
    }
    #[allow(unsafe_code)]
    fn visit_element(&self, element: SyntaxElement) -> Self::Output {
        match element {
            SyntaxElement::Node(node) => self.visit(node),
            SyntaxElement::Token(token) => self.visit_token(token),
        }
    }
}

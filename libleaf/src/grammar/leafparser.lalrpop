use crate::{
	grammar::{
		lexer,
		lexer::TokLoc,
		ast::{
			Atom,
			Expr,
			Opcode,
			AstFuncCall,
			AstFuncCallArgs,
			AstPositionalArg,
			AstNamedArg,
			AstMethodCall,
			AstStatement,
			AstAssignment,
			AstAtrOp,
			AstPropertyAccess,
		},
	},
};

grammar;

pub Program = <Statement*>;
Statement: AstStatement = {
    <MethodCall> "\n"+ => AstStatement::MethodCall(<>),
	<FuncCall> "\n"+ => AstStatement::FuncCall(<>),
	<Assignment> "\n"+ => AstStatement::Assignment(<>),
};

FuncCall: AstFuncCall = {
	<name:IdExpression> "(" <args:FuncArgs> <end:")"> => AstFuncCall::new(name, args, end.get_end())
};

pub FuncArgs:AstFuncCallArgs = {
	"\n"* <pos_args:PositionalFuncArgs> "," "\n"* <named_args:NamedFuncArgs> ","? "\n"* => AstFuncCallArgs::new(pos_args,named_args),
	"\n"* <pos_args:PositionalFuncArgs> ","? "\n"* => AstFuncCallArgs::new_only_positional(pos_args),
	"\n"* <named_args:NamedFuncArgs> ","? "\n"* => AstFuncCallArgs::new_only_named(named_args),
	("\n"*) => AstFuncCallArgs::empty(),
};

#[inline]
PositionalFuncArgs: Vec<AstPositionalArg> = {
	<arg1:PositionalFuncArg> <rest:("," "\n"* <PositionalFuncArg>)*> => {let mut v = vec![arg1]; v.extend(rest); v.into_iter().map(|box_ : Box<Expr>| AstPositionalArg::from(box_)).collect()},
};

pub PositionalFuncArg = { Expr };

#[inline]
NamedFuncArgs: Vec<AstNamedArg> = {
	<arg1:NamedFuncArg> <rest:("," "\n"* <NamedFuncArg>)*> => {let mut v = vec![arg1]; v.extend(rest); v}
};

pub NamedFuncArg: AstNamedArg = {
	<name:IdExpression> ":" <value:Expr> => AstNamedArg::from((name, value))
};

pub Expr: Box<Expr> = { // (1)
    Expr ExprOp Factor => Box::new(Expr::Op(<>)), // (2)
    Factor,
};

ExprOp: Opcode = { // (3)
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

Factor: Box<Expr> = {
    Factor FactorOp Term => Box::new(Expr::Op(<>)),
    Term,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
    "%" => Opcode::Mod,
};

Term: Box<Expr> = {
    "num" => Box::new(Expr::Atom(Atom::Number(<>))),
    "str" => Box::new(Expr::Atom(Atom::Str(<>))),
    "(" <Expr> ")",
    <MethodCall> => Box::new(Expr::MethodCall(<>)),
    <PropertyAccess> => Box::new(Expr::PropertyAccess(<>)),
    <FuncCall> => Box::new(Expr::FuncCall(<>)),
    <IdExpression> => Box::new(Expr::Atom(Atom::Id(<>))),
};

PropertyAccess: AstPropertyAccess = {
    <t:Term> "." <prop_name:IdExpression> => AstPropertyAccess::new(t, prop_name)
};

MethodCall: AstMethodCall = {
	<property_access:PropertyAccess> "(" <args:FuncArgs> <end:")"> => AstMethodCall::new(property_access, args, end.get_end()),
};

Assignment: AstAssignment = {
	<bound_name: Expr> <op: AtrOp> <val: Expr> => AstAssignment::new(bound_name, op, val),
}

AtrOp: AstAtrOp = {
	"=" => AstAtrOp::Atr,
	"+=" => AstAtrOp::AddAtr,
	"-=" => AstAtrOp::SubAtr,
	"*=" => AstAtrOp::MulAtr,
	"/=" => AstAtrOp::DivAtr,
	"%=" => AstAtrOp::ModAtr,
}

pub IdExpression = { "id" };

extern {
    type Location = usize;
    type Error = lexer::LexicalError;

    enum lexer::Tok {
        "\n" => lexer::Tok::Newline,
        "+=" => lexer::Tok::AddEq(<TokLoc>),
        "-=" => lexer::Tok::SubEq(<TokLoc>),
        "*=" => lexer::Tok::MulEq(<TokLoc>),
        "/=" => lexer::Tok::DivEq(<TokLoc>),
        "%=" => lexer::Tok::ModEq(<TokLoc>),
        "=" => lexer::Tok::Eq(<TokLoc>),
        "+" => lexer::Tok::Add(<TokLoc>),
        "-" => lexer::Tok::Sub(<TokLoc>),
        "*" => lexer::Tok::Mul(<TokLoc>),
        "/" => lexer::Tok::Div(<TokLoc>),
        "%" => lexer::Tok::Mod(<TokLoc>),
        "(" => lexer::Tok::POPEN(<TokLoc>),
        ")" => lexer::Tok::PCLOSE(<TokLoc>),
        "num" => lexer::Tok::Number(<i32>, <TokLoc>),
        "id" => lexer::Tok::Identifier(<String>, <TokLoc>),
        "str" => lexer::Tok::Str(<String>, <TokLoc>),
        ":" => lexer::Tok::Colon(<TokLoc>),
        "," => lexer::Tok::Comma(<TokLoc>),
        "." => lexer::Tok::Dot(<TokLoc>),
    }
}
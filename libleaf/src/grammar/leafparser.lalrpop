use crate::{
	grammar::{
		lexer,
		lexer::TokLoc,
		ast::{
			Atom,
			Expr,
			Opcode,
			UnaryOpcode,
			AstFuncCall,
			AstFuncCallArgs,
			AstPositionalArg,
			AstNamedExpr,
			AstMethodCall,
			AstStatement,
			AstAssignment,
			AstAtrOp,
			AstPropertyAccess,
			AstDeclaration,
		},
	},
};

grammar;

pub Program = <Statement*>;
Statement: AstStatement = {
    <MethodCall> "\n"+ => AstStatement::MethodCall(<>),
	<FuncCall> "\n"+ => AstStatement::FuncCall(<>),
	<Assignment> "\n"+ => AstStatement::Assignment(<>),
	<Declaration> "\n"+ => AstStatement::Declaration(<>),
};

FuncCall: AstFuncCall = {
	<name:IdExpression> "(" <args:FuncArgs> <end:")"> => AstFuncCall::new(name, args, end.get_end())
};

FuncArgs:AstFuncCallArgs = {
	"\n"* <pos_args:PositionalFuncArgs> "," "\n"* <named_args:NamedFuncArgs> ","? "\n"* => AstFuncCallArgs::new(pos_args,named_args),
	"\n"* <pos_args:PositionalFuncArgs> ","? "\n"* => AstFuncCallArgs::new_only_positional(pos_args),
	"\n"* <named_args:NamedFuncArgs> ","? "\n"* => AstFuncCallArgs::new_only_named(named_args),
	"\n"* => AstFuncCallArgs::empty(),
};

#[inline]
PositionalFuncArgs: Vec<AstPositionalArg> = {
	<arg1:PositionalFuncArg> <rest:("," "\n"* <PositionalFuncArg>)*> => {let mut v = vec![arg1]; v.extend(rest); v.into_iter().map(|box_ : Box<Expr>| AstPositionalArg::from(box_)).collect()},
};

PositionalFuncArg = { Expr };

#[inline]
NamedFuncArgs: Vec<AstNamedExpr> = {
	<arg1:NamedExpr> <rest:("," "\n"* <NamedExpr>)*> => {let mut v = vec![arg1]; v.extend(rest); v}
};

NamedExpr: AstNamedExpr = {
	<name:IdExpression> ":" <value:Expr> => AstNamedExpr::from((name, value))
};

AddExpr: Box<Expr> = { // (1)
    AddExpr AddOp Factor => Box::new(Expr::Op(<>)), // (2)
    Factor,
};

AddOp: Opcode = { // (3)
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

CheckExpr: Box<Expr> = {
	AddExpr RelOp AddExpr => Box::new(Expr::Op(<>)),
	AddExpr,
	UnaryNot CheckExpr => Box::new(Expr::UnaryOp(<>)),
};

UnaryNot: UnaryOpcode = {
	"not" => UnaryOpcode::Not(<>),
};

AndConditionalExpr: Box<Expr> = {
	AndConditionalExpr AndOp CheckExpr => Box::new(Expr::Op(<>)),
	CheckExpr,
};

AndOp: Opcode = {
	"and" => Opcode::And,
};

OrConditionalExpr: Box<Expr> = {
	OrConditionalExpr OrOp AndConditionalExpr => Box::new(Expr::Op(<>)),
	AndConditionalExpr,
};

OrOp: Opcode = {
	"or" => Opcode::Or,
};

RelOp: Opcode = {
	"==" => Opcode::Equal,
	">" => Opcode::G,
	"<" => Opcode::L,
	">=" => Opcode::GE,
	"<=" => Opcode::LE,
	"!=" => Opcode::NE,
	"in" => Opcode::In,
	"not" "in" => Opcode::NotIn,
};

Expr: Box<Expr> = {
	OrConditionalExpr,
};

Factor: Box<Expr> = {
    Factor FactorOp TermWithUnaryOps => Box::new(Expr::Op(<>)),
    TermWithUnaryOps,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
    "%" => Opcode::Mod,
};

TermWithUnaryOps: Box<Expr> = {
	UnaryNeg Term => Box::new(Expr::UnaryOp(<>)),
	Term,
};

Term: Box<Expr> = {
    "num" => Box::new(Expr::Atom(Atom::Number(<>))),
    "str" => Box::new(Expr::Atom(Atom::Str(<>))),
    "bool_lit" => Box::new(Expr::Atom(Atom::Bool(<>))),
    <begin:"("> <value:Expr> <end:")"> => Box::new(Expr::ParenExpr(begin.get_begin(), value, end.get_end())),
    <MethodCall> => Box::new(Expr::MethodCall(<>)),
    <PropertyAccess> => Box::new(Expr::PropertyAccess(<>)),
    <FuncCall> => Box::new(Expr::FuncCall(<>)),
    <IdExpression> => Box::new(Expr::Atom(Atom::Id(<>))),
    ArrayLit, MapLit,
};

UnaryNeg: UnaryOpcode = {
	"-" => UnaryOpcode::Neg(<>),
};

PropertyAccess: AstPropertyAccess = {
    <t:Term> "." <prop_name:IdExpression> => AstPropertyAccess::new(t, prop_name)
};

MethodCall: AstMethodCall = {
	<property_access:PropertyAccess> "(" <args:FuncArgs> <end:")"> => AstMethodCall::new(property_access, args, end.get_end()),
};

Declaration: AstDeclaration = {
	<begin: "let"> <name: IdExpression> "=" <value: Expr> => AstDeclaration::new(name, value, begin)
};

Assignment: AstAssignment = {
	<bind_name: Expr> <op: AtrOp> <val: Expr> => AstAssignment::new(bind_name, op, val),
};

AtrOp: AstAtrOp = {
	"=" => AstAtrOp::Atr,
	"+=" => AstAtrOp::AddAtr,
	"-=" => AstAtrOp::SubAtr,
	"*=" => AstAtrOp::MulAtr,
	"/=" => AstAtrOp::DivAtr,
	"%=" => AstAtrOp::ModAtr,
};

ArrayLit: Box<Expr> = {
	<b:"{"> "\n"*  <arg1:Expr> <rest:("," "\n"* <Expr>)*> ","? "\n"* <e:"}"> => Box::new(Expr::Atom(Atom::ArrayLit(({let mut v = vec![arg1]; v.extend(rest); v}, TokLoc::new(b.get_begin(), e.get_end())))))
};

MapLit: Box<Expr> = {
	<b:"{"> "\n"* <arg1:NamedExpr> <rest:("," "\n"* <NamedExpr>)*>  ","? "\n"*  <e:"}"> => Box::new(Expr::Atom(Atom::MapLit(({let mut v = vec![arg1]; v.extend(rest); v}, TokLoc::new(b.get_begin(), e.get_end())))))
};

IdExpression = { "id" };

extern {
    type Location = usize;
    type Error = lexer::LexicalError;

    enum lexer::Tok {
        "\n" => lexer::Tok::Newline,
        "+=" => lexer::Tok::AddEq(<TokLoc>),
        "-=" => lexer::Tok::SubEq(<TokLoc>),
        "*=" => lexer::Tok::MulEq(<TokLoc>),
        "/=" => lexer::Tok::DivEq(<TokLoc>),
        "%=" => lexer::Tok::ModEq(<TokLoc>),
        "=" => lexer::Tok::Eq(<TokLoc>),
        "+" => lexer::Tok::Add(<TokLoc>),
        "-" => lexer::Tok::Sub(<TokLoc>),
        "*" => lexer::Tok::Mul(<TokLoc>),
        "/" => lexer::Tok::Div(<TokLoc>),
        "%" => lexer::Tok::Mod(<TokLoc>),
        "(" => lexer::Tok::POPEN(<TokLoc>),
        ")" => lexer::Tok::PCLOSE(<TokLoc>),
        "{" => lexer::Tok::BOPEN(<TokLoc>),
        "}" => lexer::Tok::BCLOSE(<TokLoc>),
        "and" => lexer::Tok::And(<TokLoc>),
        "or" => lexer::Tok::Or(<TokLoc>),
        "==" => lexer::Tok::Equal(<TokLoc>),
        ">=" => lexer::Tok::GE(<TokLoc>),
        "<=" => lexer::Tok::LE(<TokLoc>),
        ">" => lexer::Tok::L(<TokLoc>),
        "<" => lexer::Tok::G(<TokLoc>),
        "!=" => lexer::Tok::NE(<TokLoc>),

        "in" => lexer::Tok::In(<TokLoc>),
        "not" => lexer::Tok::Not(<TokLoc>),

        "let" => lexer::Tok::Let(<TokLoc>),

		"bool_lit" => lexer::Tok::Bool(<bool>, <TokLoc>),
        "num" => lexer::Tok::Number(<i32>, <TokLoc>),
        "id" => lexer::Tok::Identifier(<String>, <TokLoc>),
        "str" => lexer::Tok::Str(<String>, <TokLoc>),

        ":" => lexer::Tok::Colon(<TokLoc>),
        "," => lexer::Tok::Comma(<TokLoc>),
        "." => lexer::Tok::Dot(<TokLoc>),
    }
}